<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN">
<html>
<head>
<title>The Application File(s)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="generator" content="Doc-O-Matic" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <link rel="STYLESHEET" href="default.css" type="text/css" />

<script type="text/javascript" src="scripts.js"></script>
</head>
<body class="Element700" onload="onBodyLoadEx('frames.html', 'topic', '00028.html');" onmousedown="onBodyMouseDown();">

<!-- Begin Popups -->

<!-- End Popups -->

<!-- Begin Page Header -->
<div class="Element710" id="areafixed">
<div class="Element94">
<a href="00020.html" target="topic">Introduction</a> &gt; <a href="00032.html" target="topic">What is MPLAB Harmony?</a> &gt; <a href="00028.html" target="topic">The Application File(s)</a></div>
<div class="Element92">
<table width="100%" cellspacing="0" cellpadding="0">
<tr><td width="25%">
<div class="Element1">
MPLAB Harmony Help Template</div>
</td><td width="25%">
<div class="Element2">
<a href="contents.html" target="tocidx">Contents</a> | <a href="00020.html" target="topic">Home</a></div>
</td><td width="25%">
<div class="Element90">
<a href="00030.html" target="topic">Previous</a> | <a href="00032.html" target="topic">Up</a> | <a href="00021.html" target="topic">Next</a></div>
</td><td width="25%">
<div class="Element96">
<a href="mailto:docerrors@microchip.com&subject=MPLAB Harmony Documentation Feedback (Topic ID: ARCH The Application File Topic Title: The Application File(s))&body=Thank you for your feedback! Please include a description of your feedback, and indicate whether you are reporting an an error in the documentation or an enhancement.">Documentation Feedback</a><br> <a href="http://support.microchip.com" target="_blank">Microchip Support</a></div>
</td></tr></table><div class="Element5">
The Application File(s)</div>
</div>
</div>

<!-- End Page Header -->

<!-- Begin Client Area -->
<div class="Element720" id="areascroll">
<div class="Element721">

<!-- Begin Page Content -->
<a name="PageContent"></a><div class="Element58">
<a name="4465736372697074696F6E"></a><div class="Element11">
<div class="Element10">
<p class="Element10">
From the point of view of a MPLAB Harmony system, an application consists of two basic functions:</p>
<ul class="Element630">
<li class="Element600">APP_Initialize</li>
<li class="Element600">APP_Tasks</li>
</ul><p class="Element10">
The application's initialization function (APP_Initialize) is normally called from the SYS_Initialize function, which is called from <span class="Element146">main</span> before entering the top-level loop. The application's &quot;tasks&quot; function (APP_Tasks) is normally called from the SYS_Tasks function, which is called from <span class="Element146">main</span> from inside the top-level loop. This is how the application's state machine is initialized and &quot;polled&quot; so that it can do its job. The SYS_Initialize function is normally implemented in the <span class="Element146">system_init.c</span> file and the SYS_Tasks function is normally implemented in the <span class="Element146">system_tasks.c</span> file. That is the convention for example and demonstration projects distributed with MPLAB Harmony and that is the case for projects generated by the MHC. You may do as you choose in your own projects, but it is recommended to follow this convention as it will make it easier to manage multiple configurations if you need them and it will be consistent with the MHC and other tools.</p><div class="Element15">
Application Initialization</div>
<p class="Element10">
An application's initialization function places the application's state machine in its initial state and may perform additional initialization if necessary. This function must not block and it should not call the routines of any other modules that may block. If something needs to be initialized that may take time to complete, that initialization should be done in the application's state machine (i.e., in its &quot;Tasks&quot; function).</p><div class="Element15">
Sample Application Initialization Function:</div>
<div class="Element13"><div class="Element12"><pre class="Element12"><strong><span style="color: #000080">void</span></strong> APP_Initialize ( <strong><span style="color: #000080">void</span></strong> )
{
    <i><span style="color: #008000">/* Place the App state machine in its initial state. */</span></i>
    appData.state       = APP_STATE_INIT;
    appData.usartHandle = DRV_HANDLE_INVALID;
}</pre></div></div>
<p class="Element10">
The sample project's initialization function initializes an internal variable and places the application's state machine in its initial state by assigning the APP_STATE_INIT enumeration value into the &quot;state&quot; member of the data structure that contains all of the data required by the application (appData). This structure is defined globally, but is only ever accessed by the application itself. The application's initialization function is called from the SYS_Initialize function (defined in <span class="Element146">system_init.c</span>), which is called from <span class="Element146">main</span> after a system Reset. Using this technique, the application is initialized (along with the rest of the system) whenever the system comes out of Reset.</p><div class="Element15">
Application Tasks</div>
<p class="Element10">
The application's state machine breaks up the job that the application must do into several short &quot;tasks&quot; that it can complete quickly, but between which it must wait for some other module to complete some tasks of its own. (In this case the other module is the USART driver.) Once each short task has completed successfully, the application transitions to another state to perform the next short task.</p><div class="Element15">
Example Application Tasks Function:</div>
<div class="Element13"><div class="Element12"><pre class="Element12"><strong><span style="color: #000080">void</span></strong> APP_Tasks ( <strong><span style="color: #000080">void</span></strong> )
{
    <i><span style="color: #008000">/* Handle returned by USART for buffer submitted */</span></i>
    DRV_HANDLE usartBufferHandle;

    <i><span style="color: #008000">/* Check the application's current state. */</span></i>
    <strong><span style="color: #000080">switch</span></strong> ( appData.state )
    {
        <i><span style="color: #008000">/* Keep trying to open the driver until we succeed. */</span></i>
        <strong><span style="color: #000080">case</span></strong> APP_STATE_INIT:
        {
            <i><span style="color: #008000">/* open an instance of USART driver */</span></i>
            appData.usartHandle = DRV_USART_Open(APP_UART_DRIVER_INDEX,
                                                 DRV_IO_INTENT_WRITE);
            <strong><span style="color: #000080">if</span></strong> (appData.usartHandle != DRV_HANDLE_INVALID )
            {
                <i><span style="color: #008000">/* Update the state */</span></i>
                appData.state = APP_STATE_SEND_MESSAGE;
            }
            <strong><span style="color: #000080">break</span></strong>;
        }

        <i><span style="color: #008000">/* Send the message when the driver is ready. */</span></i>
        <strong><span style="color: #000080">case</span></strong> APP_STATE_SEND_MESSAGE:
        {
            <i><span style="color: #008000">/* Submit message to USART */</span></i>
            DRV_USART_BufferAddWrite(appData.usartHandle, &amp;usartBufferHandle,
                                     APP_HELLO_STRING, strlen(APP_HELLO_STRING));
            <strong><span style="color: #000080">if</span></strong> ( usartBufferHandle != DRV_HANDLE_INVALID )
            {
                <i><span style="color: #008000">/* Message is accepted. Driver will transmit. */</span></i>
                appData.state = APP_STATE_IDLE;
            }
            <strong><span style="color: #000080">break</span></strong>;
        }

        <i><span style="color: #008000">/* Idle state */</span></i>
        <strong><span style="color: #000080">case</span></strong> APP_STATE_IDLE:
        <strong><span style="color: #000080">default</span></strong>:
        {
            <i><span style="color: #008000">/* Do nothing. */</span></i>
            <strong><span style="color: #000080">break</span></strong>;
        }
    }
}</pre></div></div>
<div class="Element15">
Sample Application States</div>
<p class="Element10">
The sample application's &quot;tasks&quot; function breaks the operation of the application down in to the following states using a &quot;switch&quot; statement with the following &quot;cases&quot;.</p>
<ul class="Element630">
<li class="Element600">APP_STATE_INIT</li>
<li class="Element600">APP_STATE_SEND_MESSAGE</li>
<li class="Element600">APP_STATE_IDLE</li>
</ul><p class="Element10">
The sample application is placed into the APP_STATE_INIT state by the application's initialization function before the &quot;tasks&quot; function is ever called. So, the first time the APP_Tasks function is called, the switch statement executes the code under this case and the first short &quot;task&quot; the sample application attempts to do is open the USART driver to obtain a handle so that it can transfer data over the USART. Notice that the application checks the value of the handle returned from the <a href="00521.html" target="topic">DRV_USART_Open</a> function to ensure that it is valid before it transitions to the APP_STATE_SEND_MESSAGE state. If the value of the handle retuned be the driver's &quot;open&quot; function is invalid (equal to <a href="00267.html" target="topic">DRV_HANDLE_INVALID</a>), the application stays in the APP_STATE_INIT state and continues trying to open the USART driver every time its &quot;tasks&quot; function is called. his technique allows a polled state machine to wait for something that it requires before continuing to avoid making inappropriate transitions to new states.&nbsp;</p>
<p class="Element10">
Once the application has a valid handle to the USART driver, it executes the code under the APP_STATE_SEND_MESSAGE case the next time its APP_Tasks function is called. In this state, the application calls a USART driver data transfer routine (DRV_USART_BufferAdd) to send the data data buffer string defined by the <span class="Element146">system_config.h</span> header. Then, it checks the handle returned by the DRV_USART_BufferAddWrite function to see if it is valid. If the buffer handle is valid, it indicates that the USART driver has accepted the buffer and will take responsibility for the data transfer from that point forward. The application does not have to do anything else to cause the data transfer to occur. However, if the buffer is not accepted by the driver (in which case the handle returned by the DRV_USART_BufferAddWrite function would be invalid), the application stays in the APP_STATE_SEND_MESSAGE and tries again the next time the APP_Tasks function is called.&nbsp;</p>
<p class="Element10">
Once the application has successfully passed the buffer to the USART driver, it transitions to the APP_STATE_IDLE state where it stays and does nothing any time its &quot;tasks&quot; function is called. Its job is done! A more complex application would go on to some other task or potentially begin the process again. But, this is a simple &quot;Hello World&quot; sample application. </p><div class="Element63">
<div class="TableDiv">
<table cellspacing="0" class="Table2">
<tr>
<td class="Element67" valign="top" width="10%" style="border:none;">
<div class="Element68">
<img src="Note Icon.png" border="0" alt="" title=""><strong>Note:</strong>&nbsp;</div></td><td class="Element67" valign="top" width="90%" style="border:none;">
<div class="Element68">
The application is normally initialized last, after all other modules in the system have been initialized. But, it should never assume that any other module has completed its initialization when the application is initialized or when its &quot;tasks&quot; function is first called. Instead, it should always check the return value or status from any other module it calls to ensure that the call succeeded before moving on to the next state. Following this rule makes applications more robust and allows them to handle errors more effectively.&nbsp;</div></td></tr></table></div></div>
</div>
</div>
</div>
<!-- End Page Content -->

<!-- Begin Page Footer -->
<div class="Element95">
<a href="00020.html" target="topic">Introduction</a> &gt; <a href="00032.html" target="topic">What is MPLAB Harmony?</a> &gt; <a href="00028.html" target="topic">The Application File(s)</a></div>
<div class="Element93">
<table width="100%" cellspacing="0" cellpadding="0">
<tr><td width="25%">
<div class="Element3">
MPLAB Harmony Help Template</div>
</td><td width="25%">
<div class="Element4">
<a href="contents.html" target="tocidx">Contents</a> | <a href="00020.html" target="topic">Home</a></div>
</td><td width="25%">
<div class="Element91">
<a href="00030.html" target="topic">Previous</a> | <a href="00032.html" target="topic">Up</a> | <a href="00021.html" target="topic">Next</a></div>
</td><td width="25%">
<div class="Element97">
<a href="mailto:docerrors@microchip.com&subject=MPLAB Harmony Documentation Feedback (Topic ID: ARCH The Application File Topic Title: The Application File(s))&body=Thank you for your feedback! Please include a description of your feedback, and indicate whether you are reporting an an error in the documentation or an enhancement.">Documentation Feedback</a><br> <a href="http://support.microchip.com" target="_blank">Microchip Support</a></div>
</td></tr></table></div>

<!-- End Page Footer -->
</div>
</div>

<!-- End Client Area -->
</body></html>